# 支出わけっと

スキル向上を目的に、家計管理アプリケーション **支出わけっと** を作成しました。

これはシングルページアプリケーション (SPA) として作成しており、以下の技術を採用しております。<br>
フロントエンド：**TypeScript / Next.js**<br>
バックエンド：**PHP / Laravel**<br>
インフラ：**S3+CloudFront（静的サイト） / ECS（API）**<br>

開発環境には Docker を用いており、フロントエンドとバックエンドを分離したモノレポ構成で開発しています。

---

### １度の入力で、ふたつの視点。２度手間なしの、スマートな家計管理。

支出管理表と家計簿の機能を統合し、予算設定から実績管理、可視化まで一括で行える家計管理アプリケーションです。<br >
ユーザーモード（個人/共有）を切り替えることで、個人の家計とパートナー都の家計を柔軟に管理できます。

👩 家計簿をつけてはいるけど活用できていない<br >
🧑 恋人/夫婦の支払いの分担・清算に困っている<br >
こんな困りごとを解決するために作成したアプリケーションです。

サービス URL：https://waketto.com/

【 ゲストユーザーアカウント 】<br>
メールアドレス：waketto@sample.com<br>
パスワード：GuestAccount?1234

# 目次

1. [開発背景](#1開発背景)
2. [機能一覧](#2機能一覧)
3. [画面](#3画面)
4. [使用技術](#)
5. [アプリ開発の振り返り](#5アプリ開発の振り返り)
6. [今後の展望](#6今後の展望)

## 1.開発背景

私は社会人になってから、いくつもの家計簿アプリを使って、家計管理を行ってきました。<br>
しかし、どのアプリを使用しても、以下の課題を感じていました。

### 課題 1：記録するだけでは不十分な家計簿

支出を記録することで、合計の出費を把握することはできます。

ですが、家計簿の結果から

- 自分の支出は多いのか少ないのか
- 蓄積された記録をどのように活かせばいいのか

が分からず、「お金が貯まっている実感」を得ることができませんでした。

この原因は**事前に予算を設定していない**ことだと考えています。<br>
予算を決めていないため、「何にいくら使っていいか」の基準がなく、支出の適切性を判断できませんでした。

### 課題 2：パートナーとの煩雑な精算処理

パートナーと二人暮らしをしていた際、生活費をそれぞれで支払い、月末に精算していました。<br>
しかし、この精算作業は煩雑で、手間なく管理できる方法を探していました。

### 解決策: 統合型の家計管理アプリ

これらの課題を解決するため、以下の機能を持つアプリケーションを開発しました。

1. **予算管理機能**: カテゴリー別に予算を設定し、実績と比較
2. **個人/共有モード**: 1 つのアプリで個人と共有の家計を管理
3. **支払い担当者の記録**: 誰が支払ったかを記録し、自動精算を実現

ラクに、でも効果的な家計管理を行える。<br>
そんな体験をユーザーに提供すべく、本 Web サービスの開発しました。

## 2.機能一覧

- 認証

  - ログイン / ログアウト
    - AWS Cognito による認証
    - JWT トークンベース
    - トークンの自動リフレッシュ（セッション維持）
  - ユーザー登録
    - メールアドレスとパスワードで登録
    - 確認コードによるメールアドレス検証

- アカウント管理

  - ユーザー名の変更
  - パートナー連携 / 解除
  - パスワードの変更 / リセット
  - メールアドレスの変更
  - アカウント削除

- ユーザーモード切り替え

  - 個人モード
    - ログインユーザーが登録した明細のみ表示
  - 共有モード
    - ログインユーザーとそのパートナーが登録した明細が表示
    - 支払い担当者を記録し、分担を可視化

- 明細管理

  - 明細の登録 / 更新 / 削除
  - ファイナンスモード切り替えによる表示変更
  - 明細の表示（月次ビュー）

    - テーブル形式での明細一覧表示
    - カテゴリー別円グラフによる支出割合の可視化
    - 月間合計金額の表示

  - 明細の表示（年次ビュー）

    - カテゴリー別・月別の支出推移を棒グラフで可視

- 予算管理

  - カテゴリー別に予算の登録 / 更新
  - 月別予算消化状況の表示
  - 残予算の自動計算

- サブスクリプション管理

  - サブスクリプション登録 / 更新 / 削除
  - 登録したサブスクリプションを月次明細に自動反映

## 3.画面

### 3-1.アカウント作成 / ログイン

#### アカウント作成

[gif 入れる]

**機能**

- メールアドレス認証

  - アカウントの新規作成には「メールアドレス認証」を採用しました。<br>
    これにより不正にアカウントを作成することを防ぎ、セキュリティ面の向上を図りました。

- リアルタイムバリデーション

  - パスワードにはリアルタイムバリデーションを導入しました。<br>
    これによりパスワードの設定ルールをフォーム送信前にユーザーに伝えることができ、UX の向上を図りました。

#### ログイン方法

[gif 入れる]

**機能**

- ログイン

  - 認証には AWS Cognito を採用しました。<br>
    これにより、セキュアな認証基盤を構築し、JWT トークンによる安全なセッション管理を実現しました。

### 3-2.支出管理 / 家計簿

#### 支出管理

[gif 入れる]

**機能**

- 明細の登録

  - 登録した明細は、カテゴリーごとに分類されて支出管理表に表示されます。
  - 必須項目が未入力の場合は保存ボタンを無効化し、意図しないデータの送信を防いでいます。

- 明細の表示（月次ビュー）

  - 登録した明細をテーブル形式で一覧表示します。

- 明細の編集・削除

  - 支出管理表の明細をクリックすると編集モーダルが表示され、値の変更や削除を行うことができます。

- トーストを使った結果表示

  - 操作結果をトースト通知で表示し、時間経過で自動的に消えることで UX の向上を図りました。

#### 家計簿

[gif 入れる]

**機能**

- 明細の表示（月次ビュー）

  - 登録した明細を、家計簿として可視化します。
  - カテゴリー別の円グラフで支出割合を視覚的に表示しています。

- 明細の表示（年次ビュー）

  - 月ごとにカテゴリー別で支出の推移を表示しています。
  - カテゴリー別・月別の支出推移を棒グラフで表示しています。<br>
    これにより、各カテゴリーの支出トレンドを一目で把握できます。

- 明細の登録・編集・削除

  - 支出管理と同じ明細操作をこのページでも行うことができます。

### 3-3.予算 / サブスクリプションの設定画面

#### 予算

[gif 入れる]

**機能**

- 予算の登録・更新

  - カテゴリーごとに月間または年間の予算を設定することができます。
  - 登録した予算は支出管理表に表示され、予算額・支出額・残予算を一目で確認できます。

- 予算消化状況の表示

  - 年間予算を設定したカテゴリーについて、月別の予算消化状況を表示します。
  - 12 ヶ月分の支出推移を一覧で確認でき、年間の予算管理を効率的に行えます。

#### サブスクリプション

[gif 入れる]

**機能**

- サブスクリプションの登録・更新・削除

  - サービス名称、更新間隔（月額 / 年額）、金額、契約期間（開始日 / 終了日）を設定できます。

- 支出管理への表示

  - 登録したサブスクリプションは、支出管理表と家計簿に自動的に明細として反映されます。
  - 年額の場合は月額換算（年額 ÷12）で表示されます。

### 3-4.アカウントの設定画面

ユーザー名変更 / ログイン情報変更
[gif 入れる]

パートナー設定
[gif 入れる]

**機能**

- ユーザー名の変更

  - 表示名を 10 文字以内で設定できます。

- パートナー連携

  - パートナーのユーザー ID を入力して連携できます。
  - 連携することでユーザーモードの切り替え（個人/共有）が可能になります。<br>
    共有モードでは、パートナーと明細を共有し、支払い分担を可視化できます。

- パートナー解除

  - パートナー連携を解除できます。<br>
    解除すると、共有モードで登録した予算・明細・サブスクリプションも削除されます。

- メールアドレス・パスワードの変更

  - AWS Cognito 経由でメールアドレスとパスワードを変更できます。

## 4.技術スタック

### 4-1.使用技術

本プロジェクトを構成する、主要な技術を紹介します。
実務で広く使用されている技術を採用し、実践的なスキル習得を目指しました。

| カテゴリ           | 技術                                                                                                    |
| ------------------ | ------------------------------------------------------------------------------------------------------- |
| フロントエンド     | Next.js 15.5.2 / React 19.1.0 / TypeScript 5.9.2                                                        |
| バックエンド       | PHP 8.4 / Laravel 12.0                                                                                  |
| データベース       | MySQL 8.4                                                                                               |
| 認証               | AWS Cognito / AWS Amplify 6.15.6                                                                        |
| データフェッチング | SWR / Fetch API                                                                                         |
| 環境構築           | Docker / Docker Compose                                                                                 |
| インフラ           | S3 / CloudFront / ECR / ECS Fargate / VPC / RDS /<br>ALB / Route53 / ACM / CloudWatch / Systems Manager |
| UI/スタイリング    | Shadcn/ui / Tailwind CSS                                                                                |
| CI/CD              | Github Actions                                                                                          |
| コード品質         | ESLint / Prettier / PHPUnit / Laravel Pint                                                              |

#### 技術選定理由

**【フロントエンド】**<br>
本アプリは支出の登録 / 編集 / 削除を頻繁に行い、その結果を即座に複数の画面（支出管理・家計簿・推移）に反映させる必要があります。<br>
このようなリアルタイム性の高い UX を提供するためには、SPA が最適だと判断しました。<br>

SPA を実現するために、以下の理由から React と Next.js を採用しました。

- React
  - コンポーネントベースで UI を構築できるため、支出入力フォーム / 支出管理表示 / 予算設定など繰り返し使用する UI パーツを効率的に開発・管理できます。<br>
    また、状態管理が容易で入力したデータを画面に即座に反映することができます。
- Next.js
  - SPA のリアルタイム性を維持しながら、SSR により初回ロード時間を短縮することができました。<br>
    また、App Router を採用することで、複数のページへのルーティングを直感的に管理することができました。

家計簿アプリでは、金額 / 日付 / カテゴリー / 明細 / 予算 / モードなど、多様で複雑なデータを扱います。<br>
これらのデータが正しい方で受け渡しされないと、計算ミスや表示エラーに繋がります。<br>

TypeScript を採用することで、開発段階でデータの型を厳密にチェックでき、予期せぬバグを未然に防ぐことができました。<br>
導入時は型の厳密さに苦しめられることもありましたが、支出管理と家計簿、予算と実績などの似た構造のデータを管理する際に<br>
安全にデータの受け渡しが行えるようになったことは大きなメリットでした。

**【バックエンド】**<br>
Web アプリケーションの開発に必要な機能（ルーティング・バリデーション・ORM（Eloquent））が標準で揃っており、<br>
効率的に開発を進めることができる Laravel を採用しました。

特に、本プロジェクトでは複数のテーブル（明細・予算・サブスクリプション）をリレーションしてデータを扱います。
Eloquent を使用することで、これらのリレーションを直感的に定義 / 操作できたことは、開発効率の向上に大幅に役立ちました。

またバリデーション機能を活用することで、送信されるデータの整合性をバックエンドでもチェックすることができ、データの信頼性を確保できました。

**【データベース】**<br>
本番環境で AWS RDS を使用することを想定し、MySQL を採用しました。<br>
Laravel の Eloquent ORM との相性も良く、開発環境から本番環境まで一貫したデータベース環境を構築できました。

**【認証】**<br>
本アプリでは、ユーザーのパスワードなどの機密情報を運営者側で管理せず、<br>
セキュアな認証基盤を構築するため、AWS Cognito を採用しました。

Cognito を使用することで、以下３点を実現できました。

- JWT トークンによるステートレスな認証
- トークンの自動更新によるシームレスなセッション維持
- トークン期限切れ時の再ログイン促進

AWS Amplify ライブラリと組み合わせることで、
複雑な認証フローを少ないコードで実装できました。

**【データフェッチング】**<br>
本アプリでは、明細の登録・編集・削除を行った際に、<br>
支出管理表・家計簿・グラフなど複数の画面を即座に更新する必要があります。

SWR を採用することで、以下２点を実現できました。

- データ更新後の自動再検証により、画面をリアルタイムで更新
- キャッシュ機能により、2 回目以降のアクセスで高速表示

結果として、ユーザーにストレスのない快適な操作感を提供できました。

**【環境構築】**<br>
開発環境の統一と、実務で広く使われている技術の習得を目的に、<br>
Docker / Docker Compose を採用しました。

コンテナ化により、以下を実現できました。

- ローカル環境を汚さず、プロジェクトごとに独立した環境を構築
- 開発環境と本番環境（ECS）の差異を最小化
- チーム開発時の環境差異によるトラブルを防止

また、本番環境で ECS Fargate を使用することを想定し、<br>
早期から Docker に慣れておくことも目的の一つでした。

**【インフラ】**<br>
実務で広く使用されているクラウドインフラの構築を学ぶため、AWS を採用しました。

本プロジェクトでは、フロントエンド（S3 + CloudFront）とバックエンド（ECS Fargate）を分離した構成を採用しています。

当初、フロントエンドも ECS で動かすことを検討しましたが、<br>
以下の理由から S3 + CloudFront の構成を選択しました。

- CloudFront のオリジン設定で、パスベースのルーティングを簡単に実現
  - `/api/*` → ALB（バックエンド）
  - その他 → S3（フロントエンド）
- Nginx の設定が不要になり、構成がシンプルに
- CDN による高速配信とコスト削減も実現

また、RDS（MySQL）/ VPC / ALB / Route53 / ACM など、
実務で使用される標準的なサービスを組み合わせ、スケーラブルなインフラを構築しました。

**【UI/スタイリング】**<br>
モダンで保守性の高い UI を効率的に構築するため、Tailwind CSS と Shadcn/ui を採用しました。

Tailwind CSS は、クラス名を組み合わせるだけで柔軟なスタイリングが可能で、<br>
Next.js との相性も良く、React コミュニティでも広く使用されています。

Shadcn/ui は、再利用可能な UI コンポーネントを提供しており、<br>
ボタン・フォーム・ダイアログなどを素早く実装できました。<br>
デザインがモダンでカスタマイズも容易なため、開発効率を大幅に向上させることができました。

**【CI/CD】**<br>
デプロイの自動化により開発効率を向上させるため、GitHub Actions を採用しました。

main ブランチへのマージをトリガーに、AWS（ECR / ECS / S3）への自動デプロイが実行されます。<br>
これにより、手動デプロイのミスを防ぎ、本番環境への反映を迅速に行うことができました。

**【コード品質】**<br>
技術負債を防ぎ、保守性の高いコードを維持するため、<br>
プロジェクト立ち上げ時から厳格なコード品質管理を導入しました。

フロントエンドには ESLint / Prettier、バックエンドには Laravel Pint を採用し、<br>
コーディング規約を統一しました。

また、GitHub Actions により、Pull Request 時に自動的にコードチェックを実行し、<br>
品質基準を満たさないコードはマージできない仕組みを構築しました。

### 4-2.データベース設計（ER 図）

[ER 図を追加]

### 4-3.インフラ構成図

[インフラ構成図を追加]

## 5.こだわった実装

Web アプリを実装するにあたり、以下の実装にこだわって作成しました。

- JWT トークンによるセキュアな認証
- SWR によるリアルタイムデータ更新
- 支出管理と家計簿の融合
- 個人モードと共有モードの切り替え
- サブスクリプションの明細反映

### JWT トークンによるセキュアな認証

AWS Cognito と JWT トークンを使用したステートレスな認証を実装しました。<br>
バックエンドでは、カスタムミドルウェア CognitoJwtAuth を作成し、リクエストヘッダーの JWT トークンを検証しています。

**1. リクエストヘッダーから JWT トークンを取得**<br>
API リクエストの `Authorization` ヘッダーから `Bearer` トークンを抽出します。

```
// リクエストからBearerトークンを取得
private function getTokenFromRequest(Request $request): ?string
{
  $header = $request->header('Authorization');

  if ($header && str_starts_with($header, 'Bearer ')) {
    return substr($header, 7);
  }

  return null;
}
```

**2. JWT トークンの改ざん検証**<br>
Cognito の公開鍵（JWKS）を使用して、JWT トークンが改ざんされていないかを検証します。<br>
この仕組みにより、第三者が偽造したトークンでは API にアクセスできないようになっています。

```
// Cognitoの公開鍵を取得
$publicKey = $this->getCognitoPublicKey($kid);

// JWTの改ざん検証を行い、ペイロードを取得
$payload = JWT::decode($token, $publicKey);
```

**3. トークンの有効期限チェック**<br>
トークンの有効期限（`exp`）をチェックし、期限切れの場合は認証を拒否します。<br>
有効なトークンの場合のみ、ペイロードからユーザー情報を取得し、API の処理を続行します。

```
if (isset($payload->exp) && $payload->exp < time()) {
  Log::error('JWTトークンの有効期限が切れています');
  return null;
}

// ユーザーを取得または作成
return $this->getUserFromPayload($payload);
```

この実装により、不正なリクエストを防ぐ API アクセスを実現することができました。<br>
フロントエンドでは、AWS Amplify を使用してトークンの自動更新を実装することで、ユーザーは再ログインすることなく、シームレスにアプリを利用できます。

### SWR によるリアルタイムデータ更新

本アプリでは、明細を登録・編集・削除した際に、<br>
支出管理表・家計簿・予算消化状況など複数のコンポーネントを即座に更新する必要がありました。

そこで、SWR のカスタムフックを使用してデータを取得し、`mutate` 関数で画面を更新する仕組みを実装しました。

**1. SWR でデータを取得**
各画面で必要なデータを SWR のカスタムフック（`useExpenseReport`、`useBudgetUsage`）で取得します。<br>
この時、`mutate` 関数も同時に取得しておくことで、後からデータを再取得できるようにしています。

```
const {
  data: expenseReport,
  error: expenseReportError,
  isLoading: isExpenseReportLoading,
  mutate: expenseMutate,
} = useExpenseReport(user, monthlyAndYearlyDateSelector, isAuth);

const { data: budgetUsage, mutate: budgetUsageMutate } = useBudgetUsage(
  user,
  yearlyDateSelector,
  isAuth
);
```

**2. データ更新時に複数の画面を一括更新**
明細の登録・編集・削除が成功すると、`handleUpdate` 関数が呼ばれます。<br>
この関数内で、支出管理表（`expenseMutate`）と予算消化状況（`budgetUsageMutate`）の `mutate` を実行することで、<br>
関連する全ての画面のデータが自動的に再取得されます。

```
const handleUpdte = () => {
  void expenseMutate();
  void budgetUsageMutate();
};
```

**3. 明細更新後に画面を再取得**
明細の更新が成功したら、`onSuccess` コールバックを実行します。<br>
この `onSuccess` には `handleUpdate` 関数が渡されており、自動的に関連画面のデータが再取得されます。

```
const response = await putTransaction(requestData, transactionPatch?.id);

if (response.status) {
  toast.success("取引明細を更新しました");
  resetForm();
  onSuccess(); // ← ここで handleUpdate が呼ぶ
}
```

**4. キャッシュ機能で高速表示**
SWR のキャッシュ機能により、2 秒以内の重複リクエストは自動的にキャッシュから返されます。<br>
これにより、2 回目以降のアクセスでは高速にデータを表示でき、ユーザーにストレスのない快適な操作感を提供できました。

```
export const swrConfig = {
  // キャッシュ設定
  dedupingInterval: 2000, // 2 秒間は重複リクエストを防ぐ

  // エラー時の再試行
  errorRetryCount: 3, // 最大 3 回再試行
  errorRetryInterval: 5000, // 5 秒間隔で再試行
};
```

### 支出管理と家計簿の融合

本アプリの最大の特徴は、1 度の入力で支出管理と家計簿の両方を管理できることです。<br>
この特徴を生かすために、登録された支出や予算の情報を綺麗に表示させるよう、以下の工夫を凝らしました。

**1. 予算または実績があるカテゴリーのみ表示**<br>
支出管理表では予算が 0 円かつ実績も 0 円のカテゴリーは表示しません。<br>
これにより、ユーザーに関係のないカテゴリーは自動的に非表示になり、見やすさを向上させています。

```
// 予算0 かつ 支出登録なしは非表示
if (category.budget_amount === 0 && totalAmount === 0) {
  return null;
}

・・・

// 支出登録はないが予算が0以上は表示
{totalAmount === 0 &&
category.budget_amount !== null &&
category.budget_amount > 0 ? (
  <div className="col-span-7 flex items-end justify-end gap-2">
    <span className="text-gray-500 text-xs">予算</span>
    <span className="">
      {category.budget_amount.toLocaleString()} 円
    </span>
  </div>
) : (
  // 支出登録のあるカテゴリーは表示
  <>
    <span className="col-span-4 text-right text-gray-500 text-xs">
      {category.budget_amount !== null
        ? `予算 ${category.budget_amount?.toLocaleString()} 円`
        : ``}
    </span>
    <span className="col-span-3 text-right">
      {totalAmount.toLocaleString()} 円
    </span>
  </>
)}
```

**2. 年間予算を月額換算して表示**<br>
予算設定では月次・年次を選択できますが、支出管理表では全て月額換算で表示します。<br>
例えば、「年間 12 万円の予算」を設定すると、支出管理表では「月 1 万円の予算」として表示されます。

これにより、月ごとの支出と予算を比較しやすくなり、予算管理がしやすくなりました。

```
// period_typeに応じて予算金額を計算
if ($budget) {
    $budgetAmount = $budget->period_type === 'monthly'
        ? $budget->amount
        : ceil($budget->amount / 12);
} else {
    $budgetAmount = null;
}
```

これらの仕組みにより、支出管理と家計簿を自然に融合させることができました。

### 個人モードと共有モードの切り替え

ユーザーモード（個人/共有）を切り替えることで、それぞれで別の支出を管理できるようにしました。

フロントエンドでは `ViewModeContext` でユーザーモードを管理し、<br>
モード切替時に SWR の `mutate` を使用して関連データを自動再取得します。

ユーザーモードが切り替わると、/expense-report で始まる全てのキャッシュキーに対して mutate が実行され、<br>
個人データまたは共有データが自動的に再取得されます。

```
const [user, setUser] = useState<UserMode>(() => {
    if (typeof window !== "undefined") {
        const currentUser = localStorage.getItem("userMode");

        if (currentUser === "alone" || currentUser === "common") {
            return currentUser;
        }
    }

    return "alone";
});

・・・

const handleUserChange = (mode: UserMode) => {
    setUser(mode);
    // モード切替時にデータを再取得
    void mutate(
        (key) => typeof key === "string" && key.startsWith("/expense-report")
    );
};

・・・

useEffect(() => {
    if (typeof window !== "undefined") {
        localStorage.setItem("userMode", user);
    }
}, [user]);
```

バックエンドでは、API リクエストに含まれる userMode パラメータに応じて、取得するデータの条件を切り替えています。<br>
同じ API エンドポイントで、両方のモードに対応できる設計としました。

取得の条件配下の通りです。

- 共有モード
  - payment.couple_id と user.couple_id が一致する
- 個人モード
- payment.recorded_by_user_id と user.id が一致する
- payment.couple_id が Null

```
if (isset($couple_id) && $couple_id !== null) {
    // commonモード
    $categories = Category::with(['budget' => function ($query) use ($couple_id) {
        $query->where('couple_id', $couple_id);
    }])->get();

    $paymentData = Payment::with('category', 'category.categoryGroup')
        ->where('couple_id', $couple_id)
        ->whereBetween('payment_date', [$startDate, $endDate])
        ->orderBy('payment_date', 'asc')
        ->get();
} else {
    // aloneモード
    $categories = Category::with(['budget' => function ($query) use ($userId) {
        $query->where('recorded_by_user_id', $userId)
            ->whereNull('couple_id');
    }])->get();

    $paymentData = Payment::with('category', 'category.categoryGroup')
        ->where('recorded_by_user_id', $userId)
        ->whereNull('couple_id')
        ->whereBetween('payment_date', [$startDate, $endDate])
        ->orderBy('payment_date', 'asc')
        ->get();
}
```

### サブスクリプションの明細反映

サブスクリプションとして登録した内容が、支出管理表と家計簿に自動的に明細として反映される機能を実装しました。
バックエンドでは、サブスクリプションデータを取得し、月額・年額に応じて適切な金額を計算しています。

```

```

契約開始日・終了日を考慮し、該当月のみサブスクリプションデータを取得します。年額の場合は 12 で割った金額を月次明細として表示することで、月ごとの支出を正確に把握できるようにしました。
これにより、毎月手動で入力する手間を省き、固定費の管理を効率化できました。

## 6.今後の展望

- Google 認証機能

- スマホアプリ対応

  - 支出の入力はやはりスマホの方が手軽でよい

- カテゴリーのカスタマイズ機能

  - 教育費、車検費、税金など。人の特性に応じて不要なカテゴリーがある
  - 浪費、投資の項目だけは好きに増やせてもよいかも（それ以外は不要。このアプリの特徴だし）

- 明細の自動取得（カード会社のと API 連携）

- 支出のカレンダー表記機能

  - 一部ユーザーからカレンダー形式での表示機能を実装を求められた。多くの工数がかかる見込みなので、時間と満足度の兼ね合いを慎重に見極めて必要次応じて実装する・

- ユーザー増やす

  - SNS での発信。リベシティ内での紹介

```

```
